/*
 * NAME: Kechen Zhao
 * ID: 957398
 */

import java.util.Random;
import java.util.ArrayList;
import java.util.*;

/**
 * This is the class of Quake Heap
 */


public class QuakeHeap {

    private int id_next = 1; // record the value of next identifierï¼› equal to 1 + the total number of elements generated
    private float invariant = (float) 0.6;
    public ArrayList<QuakeNode> rootList = new ArrayList<QuakeNode>(); // List of nodes in the root
    public ArrayList<QuakeNode> nodeList = new ArrayList<QuakeNode>(); // Record all nodes in the heap
    public ArrayList<element> elemList = new ArrayList<element>();
    public ArrayList<Integer> idList = new ArrayList<Integer>();

    public void set_invariant(float invariant) { this.invariant = invariant; }

    // test
    public static void main(String[] args) {
        Random rand = new Random();
        int bound = (int) Math.pow(10,7);
        int key = rand.nextInt(bound);
    }

    ///////////////////////////////////////
    // create class element
    protected static class element {

        private int id; // unique identifier (positive integer, starting from 1)
        private int key; // the priority of elements
        private QuakeNode pointer; // points to the highest quake node

        public element(int id, int key) { this.id = id; this.key = key; }

        public int get_id() { return this.id; }

        public void set_key(int key) { this.key = key; }

        public int get_key() { return this.key; }

        public void set_pointer(QuakeNode node) { this.pointer = node; }

        public QuakeNode get_Pointer() { return this.pointer; }
    }

    //////////////////////////////////////
    // create class Quake node
    protected static class QuakeNode {

        public int id = 1, key, height;
        public QuakeNode leftChild, rightChild, parent;
        public element pointer;


        public QuakeNode(element elem) {
            super();
            this.pointer = elem;
            this.leftChild = null;
            this.rightChild = null;
            this.parent = null;
            this.height = 0;
            this.key = elem.get_key();
        }


        public QuakeNode get_Parent() { return this.parent; }

        public void set_Parent(QuakeNode parent) { this.parent = parent; }

        public int get_key() { return key; }

        public void set_key(int key) { this.key = key; }

        public QuakeNode get_LeftChild() { return this.leftChild; }

        public void set_LeftChild(QuakeNode leftChild) { this.leftChild = leftChild; }

        public QuakeNode get_RightChild() { return rightChild; }

        public void set_RightChild(QuakeNode rightChild) { this.rightChild = rightChild; }

        public int get_height() { return this.height; }

        public void set_height(int height) { this.height = height; }

        public element get_Pointer() { return this.pointer; }

        public void set_Pointer(element pointer) { this.pointer = pointer; this.set_key(pointer.get_key());}
    }
////////////////////////////////////////


    // generate a new data element
    public element gen_element() {
        int id = id_next;
        idList.add(id);
        id_next = id_next + 1;
        Random rand = new Random();
        int bound = (int) Math.pow(10,7);
        int key = rand.nextInt(bound);
        element newElem = new element(id, key);
        newElem.set_pointer(null);
        elemList.add(newElem);
        return newElem;
    }


    // insert operation
    public void gen_insert() {
        element ele = gen_element(); // create a new element generated by gen_element
        // set as Quake node, no parent or child
        QuakeNode newNode = new QuakeNode(ele);
        nodeList.add(newNode);
        // set pointers
        ele.set_pointer(newNode);
        newNode.set_height(1);
        rootList.add(newNode);
    }


    // delete-min operation
    public element gen_delete_min() {
        // find the min key in root list
        int min_key = rootList.get(0).get_key();
        QuakeNode min_node = rootList.get(0);
        for (int i = 1; i < rootList.size(); i++) {
            if (rootList.get(i).get_key() < min_key) {
                min_key = rootList.get(i).get_key();
                min_node = rootList.get(i);
            }
        }
        // remove the min element in elemList
        element min_elem = min_node.get_Pointer();
        elemList.remove(min_elem);
        idList.remove(Integer.valueOf(min_elem.get_id()));

        if (min_node.get_height() == 1) {
            rootList.remove(min_node);
        } else if (min_node.get_RightChild() != null){
            min_node.get_RightChild().set_Parent(null);
            rootList.remove(min_node);
            // perform the cut first, cut the right edge, since left < right always
            rootList.add(min_node.get_RightChild());
            min_node.set_RightChild(null);
            // remove the left path that contains min_node
            while (min_node.get_LeftChild().get_LeftChild() != null) {
                min_node = min_node.get_LeftChild();
            }
        }
        if (rootList.size()>0) {
            // merge 2 trees that have the same height
            merge_tree(rootList);
            // maintain the invariant
            invariant_maintain(this);
        }
        return min_elem;
    }


    // decrease-key operation
    public void gen_decrease_key(element elem, int decKe) {
        int x_key = elem.get_key();
        elem.set_key(decKe);
        QuakeNode highest_node = elem.get_Pointer();
        // if highest node is a root, then no need to cut
        if (rootList.contains(highest_node)) {
            elem.set_key(decKe);
        }
        else if (highest_node.get_Parent() != null){
            // cut
            highest_node.get_Parent().set_RightChild(null);
            highest_node.set_Parent(null);
            elem.set_key(decKe);
            rootList.add(highest_node);
        }
        highest_node.set_Pointer(elem);
        while (highest_node.get_LeftChild() != null) {
            highest_node.set_Pointer(elem);
            highest_node = highest_node.get_LeftChild();
        }


    }


    // merge two trees that have the same height
    public void merge_tree(ArrayList<QuakeNode> rootList) {
        boolean done = false;
        if (done) {
            return;
        }
        while (!done){
            ArrayList<Integer> heightRecord = new ArrayList<Integer>();
            for (QuakeNode node : rootList){
                heightRecord.add(node.get_height());
            }
            Set<Integer> set = new HashSet<Integer>(heightRecord);
            if (! (set.size() < heightRecord.size())) {
                done = true;
            }
            else {
                ArrayList<QuakeNode> removeList = new ArrayList<QuakeNode>();
                ArrayList<QuakeNode> addList = new ArrayList<QuakeNode>();
                ArrayList<Integer> processedKey = new ArrayList<Integer>();
                for (int i = 0; i < rootList.size(); i++) {
                    // if the root has already been added or deleted, then proceed to the next one
                    if (!processedKey.contains(rootList.get(i).get_key())) {
                        QuakeNode current_node = rootList.get(i);
                        int current_height = rootList.get(i).get_height();
                        int current_key = rootList.get(i).get_key();
                        for (QuakeNode node : rootList) {
                            if (!processedKey.contains(rootList.get(i).get_key()) &&
                                    !removeList.contains(node) && node.get_key() != current_key) {
                                if (node.get_height() == current_height) {
                                    int node_key = node.get_key();
                                    int new_key = Math.min(current_key, node_key);
                                    // set pointer of new quake node
                                    QuakeNode newNode;
                                    if (new_key == current_key) {
                                        newNode = new QuakeNode(current_node.get_Pointer());
                                        current_node.get_Pointer().set_pointer(newNode);
                                    } else {
                                        newNode = new QuakeNode(node.get_Pointer());
                                        node.get_Pointer().set_pointer(newNode);
                                    }
                                    nodeList.add(newNode);
                                    newNode.set_height(current_height + 1);
                                    current_node.set_Parent(newNode);
                                    node.set_Parent(newNode);
                                    if (current_key < node_key) {
                                        newNode.set_LeftChild(current_node);
                                        newNode.set_RightChild(node);
                                    } else {
                                        newNode.set_LeftChild(node);
                                        newNode.set_RightChild(current_node);
                                    }
                                    removeList.add(current_node);
                                    processedKey.add(current_node.get_key());
                                    removeList.add(node);
                                    processedKey.add(node.get_key());
                                    addList.add(newNode);
                                }
                            }
                        }
                    }
                }
                for (QuakeNode node : removeList) {
                    rootList.remove(node);
                }
                rootList.addAll(addList);
            }
        }
    }

    // invariant maintenance
    public QuakeHeap invariant_maintain(QuakeHeap heap) {
        int height = 0;
        for (QuakeNode node : heap.nodeList) {
            if (node.get_height() > height) {
                height = node.get_height();
            }
        }
        ArrayList<Integer> levelCount = new ArrayList<Integer> (height+1);
        //initialize the array
        for (int i = 0; i < height+1; i++) {
            levelCount.add(0);
        }
        // count the nodes in each level
        for (QuakeNode node : heap.nodeList) {
            int node_height = node.get_height();
            levelCount.set(node_height, levelCount.get(node_height) + 1);
        }
        // find the cutoff level
        int cutoff = height+1;
        for (int i = 1; i < levelCount.size()-1; i++) {
            float threshold = levelCount.get(i)*invariant;
            if (threshold < levelCount.get(i+1)) {
                cutoff = i+1;
                break;
            }
        }
        if (cutoff == height+1) {
            return heap;
        }
        else {
            ArrayList<QuakeNode> removeList = new ArrayList<QuakeNode>();
            heap.rootList.clear();
            for (QuakeNode node : nodeList) {
                // remove the node that is above the cutoff
                if (node.get_height() >= cutoff) {
                    removeList.add(node);
                }
                else if (node.get_height() == cutoff-1) {
                    node.set_Parent(null);
                    rootList.add(node);
                }
            }
            for (QuakeNode node : removeList) {
                heap.nodeList.remove(node);
            }
            return heap;
        }
    }

    // helper function for experiment
    public ArrayList<element> target_element(int length) {
        ArrayList<element> targetElem = new ArrayList<>();
        Random rand = new Random();
        for (int i = 0; i < length; i++) {
            // randomly get an element
            element x = elemList.get(rand.nextInt(elemList.size()));
            targetElem.add(x);
        }
        return targetElem;
    }
    // helper function for experiment
    public ArrayList<Integer> target_decKey(ArrayList<element> targetElem) {
        ArrayList<Integer> targetKey = new ArrayList<>();
        Random rand = new Random();
        for (element elem : targetElem) {
            int target_ket = elem.get_key();
            int key_target = rand.nextInt(target_ket)+1;
            targetKey.add(key_target);
        }
        return targetKey;
    }

}

